"""
Partitioned Todo ORM models for the scalable database structure.

This module defines the SQLAlchemy ORM models for the partitioned todo system
supporting millions of users with optimal query performance. The original
monolithic 'todos' table has been replaced with:

1. TodoActive - For active todos (status: todo, in_progress)
2. TodoArchived - For completed/archived todos (status: done)
3. AITodoInteraction - For AI interaction history

Classes:
    TodoActive: Active todos partitioned by user_id
    TodoArchived: Archived todos partitioned by archived_at date
    AITodoInteraction: AI interactions partitioned by user_id
"""

from sqlalchemy import Column, String, Text, Integer, DateTime, Boolean, ForeignKey, CheckConstraint
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship, backref
from sqlalchemy.sql import func
from .base import BaseModel
import uuid


class TodoActive(BaseModel):
    """
    Active todos model for partitioned table (status: todo, in_progress).
    
    This model represents todos that are currently being worked on.
    Partitioned by user_id for optimal query performance with hash partitioning.
    
    Attributes:
        user_id: Foreign key to User (partition key)
        project_id: Optional foreign key to associated Project
        parent_todo_id: Optional foreign key for hierarchical structure
        title: Todo title (required, max 500 chars)
        description: Optional detailed description
        status: Current status (todo, in_progress, done)
        priority: Priority level 1-5, defaults to 3
        due_date: Optional deadline
        completed_at: Timestamp when marked as done
        ai_generated: Whether this todo was generated by AI
        depth: Hierarchy depth level (0-10)
        
    Relationships:
        user: The User who owns this todo
        project: Optional associated Project
        files: Associated files
        ai_interactions: AI interaction history
    """
    __tablename__ = "todos_active"
    
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    project_id = Column(UUID(as_uuid=True), ForeignKey("projects.id"))
    parent_todo_id = Column(UUID(as_uuid=True))  # Self-reference within same partition
    
    title = Column(String(500), nullable=False)
    description = Column(Text)
    status = Column(String(20), default="todo")
    priority = Column(Integer, default=3)
    due_date = Column(DateTime(timezone=True))
    completed_at = Column(DateTime(timezone=True))
    ai_generated = Column(Boolean, default=False)
    depth = Column(Integer, default=0)  # New field for hierarchy depth
    
    # Relationships
    user = relationship("User", back_populates="active_todos")
    project = relationship("Project", back_populates="active_todos")
    # Note: files and ai_interactions relationships handled through application logic due to partitioning
    
    # Table constraints
    __table_args__ = (
        CheckConstraint("status IN ('todo', 'in_progress', 'done')", name="check_status"),
        CheckConstraint("priority BETWEEN 1 AND 5", name="check_priority"),
        CheckConstraint("depth <= 10", name="check_max_depth"),
        CheckConstraint(
            "(status = 'done' AND completed_at IS NOT NULL) OR (status != 'done')",
            name="check_completed_at_when_done"
        ),
        {'extend_existing': True}
    )
    
    def __repr__(self) -> str:
        return f"<TodoActive(id={self.id}, title='{self.title[:30]}...', status='{self.status}')>"
    
    def is_completed(self) -> bool:
        """Check if the todo is completed."""
        return self.status == "done"
    
    def is_overdue(self) -> bool:
        """Check if the todo is overdue."""
        from datetime import datetime, timezone
        return (
            self.due_date is not None 
            and self.due_date < datetime.now(timezone.utc) 
            and not self.is_completed()
        )
    
    def can_have_subtasks(self) -> bool:
        """Check if this todo can have subtasks based on depth limit."""
        return self.depth < 10


class TodoArchived(BaseModel):
    """
    Archived todos model for completed todos.
    
    This model stores completed todos that have been archived.
    Partitioned by archived_at date for efficient time-based queries.
    
    Attributes:
        user_id: Foreign key to User
        project_id: Optional foreign key to associated Project
        parent_todo_id: Reference to archived parent
        title: Todo title
        description: Optional detailed description
        status: Final status (typically 'done')
        priority: Priority level
        due_date: Original deadline
        completed_at: When task was completed
        ai_generated: Whether this todo was generated by AI
        depth: Hierarchy depth level
        archived_at: When todo was moved to archive
        
    Relationships:
        user: The User who owned this todo
        project: Optional associated Project
    """
    __tablename__ = "todos_archived"
    
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    project_id = Column(UUID(as_uuid=True), ForeignKey("projects.id"))
    parent_todo_id = Column(UUID(as_uuid=True))  # Reference to archived parent
    
    title = Column(String(500), nullable=False)
    description = Column(Text)
    status = Column(String(20), nullable=False)
    priority = Column(Integer)
    due_date = Column(DateTime(timezone=True))
    completed_at = Column(DateTime(timezone=True))
    ai_generated = Column(Boolean)
    depth = Column(Integer)
    
    archived_at = Column(DateTime(timezone=True), default=func.now())
    
    # Relationships
    user = relationship("User", back_populates="archived_todos")
    project = relationship("Project", back_populates="archived_todos")
    
    # Table configuration
    __table_args__ = ({'extend_existing': True},)
    
    def __repr__(self) -> str:
        return f"<TodoArchived(id={self.id}, title='{self.title[:30]}...', archived_at='{self.archived_at}')>"


class AITodoInteraction(BaseModel):
    """
    AI interactions separated from main todos table for better performance.
    
    This model stores AI interaction history without cluttering the main todos table.
    Partitioned by user_id for efficient user-based queries.
    
    Attributes:
        todo_id: Reference to the todo this interaction is about
        user_id: Foreign key to User (partition key)
        interaction_type: Type of AI interaction (generate_subtasks, analyze, etc.)
        prompt: The prompt sent to AI
        response: The AI response
        subtasks_generated: Number of subtasks generated
        model_used: AI model that was used
        
    Relationships:
        user: The User who initiated this interaction
        todo_active: Associated active todo (if still active)
    """
    __tablename__ = "ai_todo_interactions"
    
    todo_id = Column(UUID(as_uuid=True), nullable=False)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    interaction_type = Column(String(50), nullable=False)
    prompt = Column(Text, nullable=False)
    response = Column(Text, nullable=False)
    subtasks_generated = Column(Integer, default=0)
    model_used = Column(String(100))
    
    # Relationships
    user = relationship("User", back_populates="ai_interactions")
    # Note: todo_active relationship handled through application logic due to partitioning
    
    # Table configuration
    __table_args__ = ({'extend_existing': True},)
    
    def __repr__(self) -> str:
        return f"<AITodoInteraction(id={self.id}, type='{self.interaction_type}', todo_id={self.todo_id})>"


# ====================================================================
# COMPATIBILITY LAYER FOR BACKWARD COMPATIBILITY
# ====================================================================

class Todo:
    """
    Compatibility layer that provides a unified interface to both active and archived todos.
    
    This is a virtual model that doesn't correspond to a real table.
    Use TodoService methods to interact with the actual partitioned tables.
    
    IMPORTANT: This model is for backward compatibility only during migration.
    All new code should use TodoActive and TodoArchived directly through services.
    """
    
    def __init__(self):
        # Standard todo fields for compatibility
        self.id = None
        self.user_id = None
        self.project_id = None
        self.parent_todo_id = None
        self.title = None
        self.description = None
        self.status = None
        self.priority = None
        self.due_date = None
        self.completed_at = None
        self.ai_generated = None
        self.depth = 0
        self.created_at = None
        self.updated_at = None
    
    @classmethod
    def from_active(cls, active_todo: TodoActive):
        """Create a Todo instance from TodoActive."""
        instance = cls()
        instance.id = active_todo.id
        instance.user_id = active_todo.user_id
        instance.project_id = active_todo.project_id
        instance.parent_todo_id = active_todo.parent_todo_id
        instance.title = active_todo.title
        instance.description = active_todo.description
        instance.status = active_todo.status
        instance.priority = active_todo.priority
        instance.due_date = active_todo.due_date
        instance.completed_at = active_todo.completed_at
        instance.ai_generated = active_todo.ai_generated
        instance.depth = active_todo.depth
        instance.created_at = active_todo.created_at
        instance.updated_at = active_todo.updated_at
        return instance
    
    @classmethod
    def from_archived(cls, archived_todo: TodoArchived):
        """Create a Todo instance from TodoArchived."""
        instance = cls()
        instance.id = archived_todo.id
        instance.user_id = archived_todo.user_id
        instance.project_id = archived_todo.project_id
        instance.parent_todo_id = archived_todo.parent_todo_id
        instance.title = archived_todo.title
        instance.description = archived_todo.description
        instance.status = archived_todo.status
        instance.priority = archived_todo.priority
        instance.due_date = archived_todo.due_date
        instance.completed_at = archived_todo.completed_at
        instance.ai_generated = archived_todo.ai_generated
        instance.depth = archived_todo.depth
        instance.created_at = archived_todo.created_at
        instance.updated_at = archived_todo.updated_at
        return instance
    
    def is_completed(self) -> bool:
        """Check if the todo is completed."""
        return self.status == "done"
    
    def is_overdue(self) -> bool:
        """Check if the todo is overdue."""
        from datetime import datetime, timezone
        return (
            self.due_date is not None 
            and self.due_date < datetime.now(timezone.utc) 
            and not self.is_completed()
        )


# ====================================================================
# HELPER FUNCTIONS FOR MIGRATION AND SERVICE LAYER
# ====================================================================

def get_todo_model_for_status(status: str):
    """
    Return the appropriate model class based on todo status.
    
    Args:
        status: The todo status ('todo', 'in_progress', 'done')
        
    Returns:
        TodoActive for active statuses, None for done (should be archived)
    """
    if status in ('todo', 'in_progress'):
        return TodoActive
    elif status == 'done':
        # Done todos should be archived, but temporarily might be in active
        return TodoActive  # Will be moved to TodoArchived by maintenance
    return None


def should_be_archived(todo_status: str, completed_days_ago: int = 30) -> bool:
    """
    Determine if a todo should be archived based on status and completion date.
    
    Args:
        todo_status: The current status of the todo
        completed_days_ago: Days since completion (if applicable)
        
    Returns:
        True if the todo should be moved to archive
    """
    return todo_status == 'done' and completed_days_ago >= 30